[{"title":"任务管理器的使用技巧","url":"/2026/01/22/任务管理器的使用技巧/","content":"\n### 目的\n这是一篇Windows任务管理器（Task Manager）隐藏技巧的分享贴。\n\n### 操作\n我们先打开任务管理器：\n- 在Windows桌面，按win+R键，会弹出【运行】窗口\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/Task_Manager_0.png)\n- 在空行输入`taskmgr -d`启动旧版UI的任务管理器\n  - 新版UI：标签页（进程、性能、应用历史记录等）是图标，显示在窗口的左侧。\n    ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/Task_Manager_2.png)\n  - 旧版UI(-d模式)：标签页是文字，显示在窗口的顶部。\n    ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/Task_Manager_1.png)\n\n**技巧一：按住Ctrl键，页面不刷新**\n  - 场景：当你查看“进程”列表时，CPU或内存占用一直在跳动，导致你想点击某个进程时它突然跑掉了。\n  - 操作：\n    - 切换到“进程”或“性能”标签页。\n    - 按住键盘上的Ctrl键不放。\n    - 现象：你会发现数据瞬间 **“冻结”** 了，不再跳动，方便你看清楚数据或选中某个进程。松开Ctrl键后恢复刷新。\n\n**技巧二：按住Ctrl键点击“运行新任务”，弹出管理员CMD**\n  - 场景：你需要用管理员权限运行命令行（CMD）来执行某些命令。\n  - 操作：\n    - 在任务管理器菜单栏点击【文件（File）】。\n    - 按住键盘上的Ctrl键不放。\n    - 点击【运行新任务（Run new task）】。\n    - 现象：通常点击这个按钮会弹出一个对话框让你输入命令，但按住Ctrl键点击后，它会直接打开一个已经具有管理员权限的黑色CMD窗口。\n\n### 注意点\n- 任务管理器的新版UI是针对Windows11用户来说的。\n- `taskmgr -d`的作用是强制启动Windows10风格的“旧版”任务管理器。\n\n### 参考材料\n- V2EX：https://www.v2ex.com/t/1187198#reply44","tags":["Windows"],"categories":["Windows"]},{"title":"Docker镜像备份到U盘实操","url":"/2025/12/18/Docker镜像备份到U盘实操/","content":"\n### 简介\n在树莓派等ARM设备上运行Docker时，镜像体积往往不小，而系统又多部署在TF卡或小容量SSD 上。一旦需要重装系统、迁移环境，或者做一次“真正可靠”的离线备份，如何把Docker镜像安全、完整地导出到U盘，就成了一个绕不开的问题。\n\n本文基于我在树莓派4B + Linux环境下的真实操作记录，完整展示了Docker镜像从系统导出到`exFAT`格式U盘、再导回新系统的全过程，并重点说明了挂载方式、权限设置等容易踩坑的细节，确保备份文件可写、可读、可恢复。\n\n### 目的\n本文的目的在于整理并验证一套在 Linux（树莓派）环境下可重复、可复用的 Docker 镜像备份流程，具体包括：\n\n- 将已有Docker镜像完整导出为本地`.tar`文件，实现脱离网络的离线备份\n- 使用`exFAT`格式U盘作为备份介质，解决默认自动挂载带来的权限与写入问题\n- 在新系统或新设备上通过`docker load`原样恢复镜像，确保镜像标签与`IMAGE ID`不发生变化\n\n通过该流程，可以在系统重装、设备迁移或故障恢复时，快速还原Docker运行环境，避免重复拉取镜像或依赖外部网络。\n\n### 导出Docker镜像到U盘\n1. 插入U盘，查看设备名（通常是sda1或sdb1）\n   1. 执行命令 `lsblk`\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_0.png)\n2. 先卸载devmon的挂载\n   1. 执行 `sudo umount /media/devmon/DockerIMGs`\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_1.png)\n3. 准备一个“正式”的挂载点\n   1. 执行 `sudo mkdir -p /mnt/docker-usb`\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_2.png)\n4. 用exFAT正确姿势挂载（关键在这里）\n   1. 执行\n      ```shell\n      sudo mount -t exfat \\\n      -o uid=1000,gid=1000,umask=022 \\\n      /dev/sdb1 /mnt/docker-usb\n      ```\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_3.png)\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_4.png)\n5. 创建备份文件夹\n   1. 进入操作目录 `cd /mnt/docker-usb`\n   2. 创建备份文件夹 `sudo mkdir docker_images_backup`\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_5.png)\n6. 导出镜像到U盘\n   1. 执行备份命令\n   2. 请替换为你的实际目录路径与镜像名\n      ```shell\n      sudo docker save -o /mnt/docker-usb/docker_images_backup/transmission_latest.tar lscr.io/linuxserver/transmission:latest\n      sudo docker save -o /mnt/docker-usb/docker_images_backup/cloudreve_4.10.1-arm.tar cloudreve:4.10.1-arm\n      ```\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_6.png)\n7. 出完成后检查文件大小\n   1. 执行 `ls -lh /mnt/docker-usb/docker_images_backup`\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_7.png)\n8. 安全卸载U盘\n   1. 执行 `sudo umount /mnt/docker-usb`\n\n### 导回Docker镜像到Linux系统\n1. 插入U盘\n   - 系统会自动挂载（通常到/mnt/docker-usb或类似路径，你之前就是这个）\n2. 确认U盘挂载路径并查看备份文件\n   1. 执行 `lsblk`\n   2. 或 `ls /mnt/docker-usb/docker_images_backup`\n3. 导入镜像到Docker\n   1. 执行 \n      ```shell\n      sudo docker load -i /media/devmon/ImgBackU/docker_images_backup/openwrt-aarch64.tar\n      ```\n   2. 导入过程中会看到类似输出 `Loaded image: buddyfly/openwrt-aarch64:latest`\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_8.png)\n4. 验证镜像是否成功导入\n   1. 执行查看 `sudo docker images`\n   2. 你应该能看到 `buddyfly/openwrt-aarch64:latest` 和其他镜像又回来了，和以前一模一样（包括IMAGE ID）\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/Docker%E9%95%9C%E5%83%8F%E5%A4%87%E4%BB%BD%E5%88%B0U%E7%9B%98%E5%AE%9E%E6%93%8D/Docker_IMG_Backup_9.png)\n5. 完成后可以安全卸载U盘（可选）\n   1. 执行 `sudo umount /mnt/usb`\n   2. 然后拔掉U盘\n\n### 参考资料\n- [Docker官方文档 - docker save](https://docs.docker.com/reference/cli/docker/image/save/)\n- [Docker官方文档 - docker load](https://docs.docker.com/reference/cli/docker/image/load/)\n- [Linux mount exFAT 文件系统](https://wiki.archlinux.org/title/ExFAT)（解释uid/gid/umask参数用法）","tags":["树莓派","Linux"],"categories":["树莓派"]},{"title":"NS启动Hekate界面引导加载程序","url":"/2025/12/17/NS启动Hekate界面引导加载程序/","content":"\n### 简介\n以下是一套给2017年初代Nintendo Switch（可进入RCM的那一批）使用的启动链说明。它不是在“教你玩游戏”，而是在教主机怎么被“唤醒”到一个完全不同的启动世界里。\n下面我把它拆开讲清楚：它是什么、为什么要这么做、每一步在干嘛、最终能得到什么。\n\n先给一句总览版结论：\n这是在利用初代NS的硬件漏洞，把官方系统的“钥匙”暂时放一边，改用一个你自己控制的启动加载器（Hekate），从而运行第三方系统（Atmosphère，大气层）和自制软件。\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_9.png)\n\n### 名词解释\n- 初代NS（2017）\n  - 只限 2017 初代 NS 的原因很简单： 这批机器的 Tegra X1 芯片存在不可修补的硬件漏洞（Fusee-Gelee）。 后续版本（2018 后、续航版、Lite、OLED）已经在硬件层面堵死。\n  - 这是物理层漏洞，不是软件 bug，所以升级系统没用，重刷系统没用，任天堂也补不了。\n  - 这也是为什么它被称为“天生可破解”。\n- RCM模式（Recovery Mode）\n  - RCM是NVIDIA芯片自带的低级恢复模式，原本是给工厂和维修用的。\n  - 在RCM状态下：\n    - 主机还没加载任天堂系统\n    - 可以从USB接收“启动指令”（payload）\n    - 相当于BIOS级别的入口\n  - 你整套操作，目的只有一个：让NS进入RCM，并向它注入Hekate。\n- 红色金属卡片（RCM Jig）\n  - 这东西的作用非常“原始”\n    - 短接右Joy-Con插槽里的特定针脚\n    - 欺骗主机：你在请求进入RCM\n  - 它不含程序、不联网、不存数据，只是一个物理开关。\n- RCMloader（蓝灯那个）\n  - 这是一个U盘大小的硬件，里面存着payload。\n  - 它做的事情：\n    - 通过USB把`hekate.bin`送进主机内存\n    - 相当于“点火器”\n    - 蓝灯 = 已成功注入payload\n  - 没有它，你就得用电脑或手机每次手动推送。\n- Hekate是什么？\n  - Hekate是一个启动引导加载器（Bootloader），地位类似于PC的GRUB。\n  - 它能做的事：\n    - 启动大气层（Atmosphère）\n    - 备份/恢复NAND（系统命根子）\n    - 管理emuMMC（虚拟系统）\n    - 查看硬件状态\n    - 在多个系统之间切换\n  - 一句话：Hekate是“系统的系统”。\n- 大气层（Atmosphère）\n  - 这是当前主流的Switch自制系统环境（CFW）。\n  - 它不是一个“替代系统”，而是：\n    - 在原系统之上打补丁\n    - 解锁原本被禁止的能力\n  - 能干嘛：\n    - 运行自制软件（Homebrew）\n    - 安装插件（如特斯拉浮窗）\n    - 使用emuMMC（不碰真实系统）\n    - 调试、开发、研究\n- 特斯拉浮窗（Tesla Overlay）\n  - 这是一个系统级插件框架。\n  - 效果类似：\n    - 游戏中按组合键\n    - 呼出浮窗\n    - 实时查看或调整参数\n  - 它本身不破解，只是增强体验和可控性。\n\n### 确认设备是否适配\n一台受Fusee-Gelee漏洞影响的Nintendo Switch主机，即所谓的“软破机”。若要确认主机是否符合条件，请于主机的官方系统设置中读取主机编号（也可于机身下方白色贴纸上读取），并对照本表进行查询：\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_8.png)\n\n### 操作步骤\n> 仅限2017初代NS适用\n1. 把NS内存卡取出后，在电脑里格式化为FAT32格式。\n2. 把”大气层1.9.2+20.2.0固件纯净版[含特斯拉浮窗]“里的文件全部拷贝到NS内存卡里。\n3. 把NS内存卡插入到NS机子里，拿下右手柄。\n4. 先普通开机，不要进入主页面。\n5. 插入红色金属卡片，插入RCMloader，灯为蓝色。\n6. 再长按开关机键直接关机。\n7. 长按音量加键，然后轻点一下NS开机键。\n8. 即可进入Hekate界面\n\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_10.png)\n\n### Hekate界面详细介绍\n- HOME 主页\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_0.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_1.png)\n- TOOLS 界面\n  > 注意：使用SD Card功能，将SD挂载为U盘，使用完之后，必须在电脑弹出U盘，等close选项亮起以后才能拔线。\n  \n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_2.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_3.png)\n- USB TOOLS\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_4.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_5.png)\n- Console Info 主机信息\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_6.png)\n- Options 选项\n  > 建议改为：自动启动虚拟系统，并设置合适的启动延迟时间\n  \n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/NS%E5%90%AF%E5%8A%A8Hekate%E7%95%8C%E9%9D%A2%E5%BC%95%E5%AF%BC%E5%8A%A0%E8%BD%BD%E7%A8%8B%E5%BA%8F/NS_Startup_Hekate_7.png)\n\n### 整套流程的真正目的是什么？\n不是“为了折腾”。 而是三件事：\n- 控制启动权\n  - 谁控制启动，谁控制系统。\n  - Hekate 把这个权力从官方手里暂时借过来。\n- 系统隔离（emuMMC）\n  - 一个干净的官方系统（联网、正版）\n  - 一个完全隔离的实验系统（自制、插件）\n  - 这不是作恶，而是工程上的风险隔离。\n- 自由探索硬件\n  - Switch本质是一台ARM Linux设备。\n  - 这套流程让它：\n    - 像一台真正的“个人计算机”\n    - 而不是只能按按钮的黑盒\n\n### 参考资料\n- Hekate官方源代码与文档\n  - https://github.com/CTCaer/hekate\n- Atmosphere官方源代码与文档\n  - https://github.com/Atmosphere-NX/Atmosphere\n- Hekate界面详细介绍\n  - https://docs.qq.com/doc/DVVpQcmd1RFNpUnNL\n- NH Switch Guide（最权威的入门文档）\n  - https://switch.hacks.guide/\n- Nintendo Switch破解原理:详解Fusée Gelée漏洞\n  - https://github.com/Ginurx/fusee_gelee_explained_in_chinese\n- 万物皆可 Android：给任天堂 Switch 掌机刷上 LOS 17.1\n  - https://www.ithome.com/0/534/885.htm\n- 游戏机黑客词汇表\n  - http://gledos.science/hacking-game-console-word-list.html#%E5%9B%BD%E4%BA%A7%E8%8A%AF%E7%89%87\n- 任天堂Switch的破解史\n  - https://xmper.cc/2023/02/21/Switch-jailbreaking-history/\n- Tesla - The Nintendo Switch Overlay Menu\n  - https://gbatemp.net/threads/tesla-the-nintendo-switch-overlay-menu.557362/\n- Tesla-Menu官方源代码与文档\n  - https://github.com/WerWolv/Tesla-Menu\n- Tesla-Menu\n  - https://switch.hacks.guide/homebrew/tesla-menu.html","tags":["游戏机","NS"],"categories":["任天堂NS"]},{"title":"任天堂Switch安装安卓TV系统","url":"/2025/12/17/任天堂Switch安装安卓TV系统/","content":"\n### 前期准备\n- 用泡泡龙电玩版Hekate\n- 用LineageOS的安卓TV15版本固件\n- 确保SD卡格式化为FAT32或exFAT\n- 确保Hekate版本大于等于6.0.3\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_0.png)\n\n### MindTheGapps 简介\n- Download MindTheGapps: Custom Google Apps Package for Android\n  - 链接：https://mindthegapps.com/\n    ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_1.png)\n- Why Choose MindTheGapps?\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_2.png)\n- How to Install MindTheGapps\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_3.png)\n\n### 安装Gapps（安卓TV14系统内部没有）\n1. 确认Android TV系统已安装但尚未首次启动.\n   1. 你提到已经“安装好了 Android TV 14 系统并进入过一次”，这属于已首次启动系统的状态。此时直接安装GApps会很可能引发系统崩溃。因此，需要先重置数据，再安装GApps。\n2. 启动到Recovery并执行Data清空。\n   1. 长按 音量上 + 启动 Hekate → More Configs → 持 Volume Up 选 LineageOS Recovery，进入恢复模式。\n   2. 在 Recovery 菜单中执行 Factory Reset → Format data / factory reset，清除 Android 的 data 和 cache 分区（不会影响 HOS 或 Switch 原系统）\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_4.png)\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_5.png)\n   3. 下载合适的GApps包\n      1. 根据你的系统版本（LineageOS 21 – Android 14）和架构（Switch v1 是 ARM64），选择对应的 GApps 包。对于 Android TV，推荐使用适配 TV 的包类型（如 MindTheGapps 或 OpenGApps TV stock）\n      2. 下载这个包 → MindTheGapps-14.0.0-arm64-ATV-full-20240523_192016.zip\n         ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_6.png)\n         ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_7.png)\n      3. 下载官网\n         - https://wiki.lineageos.org/gapps/\n         - https://github.com/MindTheGapps/14.0.0-arm64-ATV/releases/tag/MindTheGapps-14.0.0-arm64-ATV-20240523_192151\n   4. 通过Choose from SWITCH SD安装GApps\n      1. 在Recovery中点击Apply Update → Choose from SWITCH SD\n         ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_8.png)\n         ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_9.png)\n         ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_10.png)\n      2. 当看到“Signature verification failed”提示时选择“Yes”继续安装（这是正常情况）\n   5. 回到Recovery主界面并重启\n      1. 安装完毕后，选择Recovery中的“Back”或返回箭头，然后点击Reboot system now，系统将进入首次带GApps的Android TV\n   6. 总结\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E4%BB%BB%E5%A4%A9%E5%A0%82Switch%E5%AE%89%E8%A3%85%E5%AE%89%E5%8D%93TV%E7%B3%BB%E7%BB%9F/NS_Install_AndroidTV_11.png)\n\n### Magisk\n- 目的：让NS的ATV解锁ROOT模式。\n- 针对OLED型号推荐v25.2\n- 下载这个“Magisk-v25.2.apk”\n  - https://github.com/topjohnwu/Magisk/releases\n  - https://github.com/topjohnwu/Magisk/releases/tag/v25.2\n\n### Youtube教学参考\n- 双系统切换！给Switch刷入大气层及Android11系统，并Root\n  - 莫老师的附件表\n    - https://zxmls.lol/#/?id=ep150-双系统切换！给switch刷入大气层及android11系统，并root\n    <div class=\"video-container\">\n      <iframe src=\"https://www.youtube.com/embed/6g0uDHGaRxU?start=30&rel=0&modestbranding=1\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n    </div>\n- 任天堂SWITCH游戏机最新2025刷最新安卓15系统教程，Nintendo SWITCH game console latest 2025 flash latest Android 15\n  <div class=\"video-container\">\n    <iframe src=\"https://www.youtube.com/embed/n1zm5zk01hA?start=30&rel=0&modestbranding=1\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n  </div>\n- 小亮电玩 switch全系列支持刷安卓11教程，支持oled版，这个安卓确实惊喜比较大\n  <div class=\"video-container\">\n    <iframe src=\"https://www.youtube.com/embed/3LNXBqUFgGY?start=30&rel=0&modestbranding=1\" frameborder=\"0\" allow=\"autoplay; encrypted-media\" allowfullscreen></iframe>\n  </div>\n\n### References\n- Switchroot下载地址\n  - https://download.switchroot.org/\n- LineageOS下载地址\n  - https://download.lineageos.org/devices/nx/builds\n- Switchroot LineageOS Downloader\n  - https://github.com/sthetix/Switchroot-LineageOS-Downloader\n- 各个组织官网\n  - https://wiki.switchroot.org/wiki/\n  - https://wiki.lineageos.org/\n- 两个组织提供的成功可支持NS的安卓版本\n  - https://wiki.lineageos.org/devices/nx/variant4/\n  - https://wiki.switchroot.org/wiki/android/android-14-15","tags":["游戏机","NS"],"categories":["任天堂NS"]},{"title":"获取本机系统信息","url":"/2025/12/14/获取本机系统信息/","content":"\n### 简介\n- For Windows\n  - 这是一个专门为Windows操作系统设计的系统信息收集脚本，使用Bash脚本编写。它能够在Windows的命令行环境（包括Git Bash、Cygwin、WSL等）中运行，通过调用Windows原生命令和工具来获取详细的系统配置信息。\n- For Linux\n  - 这是一个专为Linux和macOS系统设计的系统信息收集脚本，同样使用Bash编写。它充分利用Linux系统的特性（如/proc文件系统、标准命令行工具）来获取详细的系统信息。\n### 目的\n- For Windows\n  - 快速诊断系统配置：帮助用户和IT管理员快速了解Windows主机的硬件和软件配置\n  - 系统信息存档：在系统部署、故障排查或升级前记录系统状态\n  - 远程技术支持：通过运行脚本获取详细信息，便于远程技术支持分析问题\n  - 系统健康检查：监控关键系统指标，如内存使用、磁盘空间、CPU负载等\n  - 网络配置分析：显示内外网IP地址、网络接口配置和地理位置信息\n- For Linux\n  - 全面系统概览：提供从硬件到软件的完整系统快照\n  - 性能监控基线：建立系统性能基准，用于后续的性能监控和调优\n  - 服务器状态检查：适用于服务器管理和监控，特别关注运行时间和负载\n  - 故障排除工具：为系统故障和性能问题提供诊断信息\n  - 兼容性验证：检查系统是否满足特定软件或应用的运行要求\n\n### 适用场景\n- For Windows\n  - IT管理员进行系统审计和资产管理\n  - 技术支持人员收集客户系统信息进行故障分析\n  - 开发人员确认开发环境的硬件配置\n  - 系统迁移或升级前的兼容性检查\n  - 安全审计和合规性检查\n- For Linux\n  - 服务器管理和监控\n  - 云主机配置验证\n  - 容器化环境的基础镜像检查\n  - 分布式系统部署前的环境检查\n  - 系统性能调优和容量规划\n  - 安全加固和合规性审计\n\n### 两个脚本的共同特点\n- 技术特点\n  - 跨平台兼容性：虽然各自针对不同平台，但都使用标准的Bash语法\n  - 无需安装：依赖系统内置命令，不需要额外安装软件包\n  - 颜色化输出：使用绿色文本提高可读性\n  - 模块化信息：信息按类别分组显示，结构清晰\n  - 错误处理：对命令失败的情况有适当处理\n- 信息收集范围\n  - 基本信息：主机名、用户名、操作系统版本\n  - 硬件信息：CPU型号、内存大小、磁盘配置\n  - 网络信息：IP地址（公网/内网）、网络接口、地理位置\n  - 系统状态：运行时间、启动时间、时区\n  - 存储信息：磁盘分区、挂载点、使用情况\n- 使用价值\n  - 效率提升：自动化收集信息，避免手动检查每个项目\n  - 标准化输出：提供一致的输出格式，便于比较和分析\n  - 历史记录：可保存输出结果作为系统变更的参考\n  - 可扩展性：可根据需要轻松添加新的信息收集功能\n  - 教育和学习：帮助用户了解系统结构和配置\n\n### 效果图\n- For Windows\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/sysinfo_0.png)\n- For Linux\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/sysinfo_1.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/sysinfo_2.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E8%8E%B7%E5%8F%96%E6%9C%AC%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF/sysinfo_3.png)\n\n### 适用于Windows版本脚本\n- 获取Win本机系统信息\n```shell\n#!/bin/bash\n\n# Windows 主机系统信息收集脚本\n# 颜色设置\necho -e \"\\e[32m\"\n\necho \"=== Windows主机系统信息 ===\"\n\n# 主机名和用户名\necho \"主机名: $(hostname)\"\necho \"用户名: ${USERNAME:-$USER}\"\n\n# 网络地址信息\necho \"=== 网络地址信息 ===\"\n\n# 公网IP\nif command -v curl &>/dev/null; then\npublic_ip=$(curl -s --max-time 5 ifconfig.me 2>/dev/null || curl -s --max-time 5 ipinfo.io/ip 2>/dev/null || echo \"无法获取\")\nelse\npublic_ip=\"无法获取 (curl未安装)\"\nfi\necho \"公网IP地址: $public_ip\"\n\n# IP地理位置\nif command -v curl &>/dev/null && [[ \"$public_ip\" != \"无法获取\" && \"$public_ip\" != \"无法获取 (curl未安装)\" ]]; then\necho -n \"IP地理位置: \"\nlocation=$(curl -s --max-time 3 \"ipinfo.io/$public_ip/json\" 2>/dev/null | grep -E '\"city\"|\"region\"|\"country\"' | \\\nsed 's/.*: \"//;s/\",//' | tr '\\n' ' ' | sed 's/ $//')\n[[ -n \"$location\" ]] && echo \"$location\" || echo \"未知\"\nelse\necho \"IP地理位置: 需要网络连接\"\nfi\n\n# 内网IP地址\necho \"内网IP地址:\"\nipconfig 2>/dev/null | grep -E \"(IPv4|IP.v4)\" | grep -v \"169.254.\" | while read line; do\ninterface=$(echo \"$line\" | cut -d' ' -f1 | tr -d ':')\nip=$(echo \"$line\" | cut -d: -f2 | sed 's/^[ \\t]*//')\n[[ -n \"$ip\" ]] && echo \"  $interface: $ip\"\ndone\n\n# 系统详细信息\necho \"=== 系统详细信息 ===\"\n\nif command -v systeminfo &>/dev/null; then\nsysinfo=$(systeminfo 2>/dev/null)\n\n    # 操作系统版本\n    os_version=$(echo \"$sysinfo\" | grep \"OS Name\" | head -1 | cut -d: -f2 | sed 's/^[ \\t]*//')\n    echo \"操作系统版本: $os_version\"\n    \n    echo \"内核版本: $(uname -r)\"\n    \n    # 启动设备\n    boot_device=$(echo \"$sysinfo\" | grep -i \"Boot Device\" | head -1 | cut -d: -f2- | sed 's/^[ \\t]*//')\n    [[ -n \"$boot_device\" ]] && echo \"启动设备: $boot_device\"\n    \n    # 时区\n    time_zone=$(echo \"$sysinfo\" | grep -i \"Time Zone\" | head -1 | cut -d: -f2- | sed 's/^[ \\t]*//')\n    [[ -n \"$time_zone\" ]] && echo \"时区: $time_zone\"\n    \n    # 系统运行时间\n    boot_time=$(echo \"$sysinfo\" | grep -i \"System Boot Time\" | head -1 | cut -d: -f2- | sed 's/^[ \\t]*//')\n    if [[ -n \"$boot_time\" ]]; then\n        echo \"系统启动时间: $boot_time\"\n        \n        # 计算运行时间\n        boot_date=$(date -d \"$boot_time\" \"+%s\" 2>/dev/null || echo \"\")\n        if [[ -n \"$boot_date\" ]]; then\n            current_date=$(date \"+%s\")\n            uptime_seconds=$((current_date - boot_date))\n            days=$((uptime_seconds / 86400))\n            hours=$(( (uptime_seconds % 86400) / 3600 ))\n            minutes=$(( (uptime_seconds % 3600) / 60 ))\n            echo \"系统运行时间: ${days}天 ${hours}小时 ${minutes}分钟\"\n        fi\n    fi\nelse\necho \"操作系统版本: 无法获取 (systeminfo未找到)\"\necho \"内核版本: $(uname -r)\"\nfi\n\n# CPU信息\necho \"=== CPU信息 ===\"\n\nif command -v wmic &>/dev/null; then\ncpu_info=$(wmic cpu get name 2>/dev/null | tail -2 | head -1 | sed 's/^[ \\t]*//;s/[ \\t]*$//')\n[[ -n \"$cpu_info\" && ! \"$cpu_info\" =~ \"Name\" ]] && echo \"CPU型号: $cpu_info\" || echo \"CPU型号: 无法获取\"\nelse\necho \"CPU型号: 无法获取 (wmic未找到)\"\nfi\n\n# 内存信息\necho \"=== 内存信息 ===\"\n\nif command -v wmic &>/dev/null; then\nmemory_bytes=$(wmic computersystem get TotalPhysicalMemory 2>/dev/null | grep '[0-9]' | awk '{print $1}')\nif [[ -n \"$memory_bytes\" ]]; then\nmemory_gb=$(echo \"$memory_bytes\" | awk '{printf \"%.2f\", $1/1024/1024/1024}')\necho \"内存大小: ${memory_gb}GB\"\n\n        # 获取可用内存\n        free_bytes=$(wmic OS get FreePhysicalMemory 2>/dev/null | grep '[0-9]' | awk '{print $1 * 1024}')\n        if [[ -n \"$free_bytes\" ]]; then\n            free_gb=$(echo \"$free_bytes\" | awk '{printf \"%.2f\", $1/1024/1024/1024}')\n            used_gb=$(echo \"$memory_bytes $free_bytes\" | awk '{printf \"%.2f\", ($1-$2)/1024/1024/1024}')\n            echo \"内存使用: 已用 ${used_gb}GB / 可用 ${free_gb}GB\"\n        fi\n    else\n        echo \"内存大小: 无法获取\"\n    fi\nelse\necho \"内存大小: 无法获取 (wmic未找到)\"\nfi\n\n# 磁盘信息\necho \"=== 磁盘分区信息 ===\"\n\necho \"逻辑磁盘信息:\"\nif command -v wmic &>/dev/null; then\nwmic logicaldisk where \"drivetype=3\" get deviceid,size,freespace,volumename /format:list 2>/dev/null | \\\ntr -d '\\r' | awk -F'=' '\n/DeviceID/ {drive=$2}\n/Size/ {size=$2/1024/1024/1024}\n/FreeSpace/ {free=$2/1024/1024/1024; used=size-free}\n/VolumeName/ {volumename=$2}\n/^$/ && drive {\nif (volumename == \"\") volumename=\"本地磁盘\";\nprintf \"  %s (%s): 总大小=%.2fGB, 已用=%.2fGB, 可用=%.2fGB\\n\",\ndrive, volumename, size, used, free;\ndrive=\"\"; volumename=\"\"\n}\n'\nelse\necho \"  WMIC命令不可用\"\nfi\n\n# 使用DF命令查看挂载点（备选方法）\nif command -v df &>/dev/null; then\necho -e \"\\n使用DF命令查看挂载点:\"\ndf -h 2>/dev/null | grep -E \"^[A-Z]:\" | while read line; do\necho \"  $line\" | awk '{\nprintf \"  %s: 总大小=%s, 已用=%s, 可用=%s, 使用率=%s\",\n$1, $2, $3, $4, $5;\nif (NF > 5) {\nprintf \", 挂载点=\";\nfor(i=6;i<=NF;i++) printf \"%s \", $i;\n}\nprint \"\"\n}'\ndone\nfi\n\necho -e \"\\n=== 物理磁盘信息 ===\"\nif command -v wmic &>/dev/null; then\nwmic diskdrive get model,size /format:list 2>/dev/null | \\\ntr -d '\\r' | awk -F'=' '\n/Model/ {model=$2}\n/Size/ {size=$2/1024/1024/1024; printf \"  %s: %.2fGB\\n\", model, size}\n' | head -10\nelse\necho \"  WMIC命令不可用\"\nfi\n\n# 用户信息\necho -e \"\\n=== 当前登录用户 ===\"\necho \"  当前用户: ${USERNAME:-$USER}\"\n\necho -e \"\\e[0m\"\n```\n\n\n### 适用于Linux版本脚本\n- 获取Linux本机系统信息\n```shell\n#!/bin/bash\n\n# Linux/macOS 主机系统信息收集脚本\n# 颜色设置\necho -e \"\\e[32m\"\n\n# 检测是Linux还是macOS\nif [[ \"$(uname)\" == \"Darwin\" ]]; then\n    OS_TYPE=\"macOS\"\nelse\n    OS_TYPE=\"Linux\"\nfi\n\necho \"=== ${OS_TYPE}主机系统信息 ===\"\n\n# 主机名和用户名\necho \"主机名: $(hostname)\"\necho \"用户名: $USER\"\n\n# 网络地址信息\necho \"=== 网络地址信息 ===\"\n\n# 公网IP\nif command -v curl &>/dev/null; then\n    public_ip=$(curl -s --max-time 5 ifconfig.me 2>/dev/null || curl -s --max-time 5 ipinfo.io/ip 2>/dev/null || echo \"无法获取\")\nelse\n    public_ip=\"无法获取 (curl未安装)\"\nfi\necho \"公网IP地址: $public_ip\"\n\n# IP地理位置\nif command -v curl &>/dev/null && [[ \"$public_ip\" != \"无法获取\" && \"$public_ip\" != \"无法获取 (curl未安装)\" ]]; then\n    echo -n \"IP地理位置: \"\n    location=$(curl -s --max-time 3 \"ipinfo.io/$public_ip/json\" 2>/dev/null | grep -E '\"city\"|\"region\"|\"country\"' | \\\n        sed 's/.*: \"//;s/\",//' | tr '\\n' ' ' | sed 's/ $//')\n    [[ -n \"$location\" ]] && echo \"$location\" || echo \"未知\"\nelse\n    echo \"IP地理位置: 需要网络连接\"\nfi\n\n# 内网IP地址\necho \"内网IP地址:\"\nif command -v ip &>/dev/null; then\n    ip -4 addr show 2>/dev/null | grep -v \"127.0.0.1\" | grep inet | awk '{print \"  \"$NF\": \"$2}'\nelif command -v ifconfig &>/dev/null; then\n    ifconfig 2>/dev/null | grep -E \"inet \" | grep -v \"127.0.0.1\" | awk '{print \"  \"$1\": \"$2}'\nelse\n    echo \"  无法获取网络接口信息\"\nfi\n\n# 系统详细信息\necho \"=== 系统详细信息 ===\"\n\nif [[ \"$OS_TYPE\" == \"macOS\" ]]; then\n    echo \"操作系统: macOS $(sw_vers -productVersion 2>/dev/null || echo '未知')\"\nelif [[ -f /etc/os-release ]]; then\n    source /etc/os-release\n    echo \"操作系统: $NAME $VERSION\"\nelse\n    echo \"操作系统: 无法确定\"\nfi\n\necho \"内核版本: $(uname -r)\"\necho \"系统架构: $(uname -m)\"\n\n# 系统运行时间\necho \"=== 系统运行时间 ===\"\n\nif [[ \"$OS_TYPE\" == \"macOS\" ]]; then\n    # macOS获取运行时间\n    if command -v sysctl &>/dev/null; then\n        boot_time=$(sysctl -n kern.boottime 2>/dev/null | awk '{print $4}' | sed 's/,//')\n        if [[ -n \"$boot_time\" ]]; then\n            current_time=$(date +%s)\n            uptime_seconds=$((current_time - boot_time))\n            days=$((uptime_seconds / 86400))\n            hours=$(( (uptime_seconds % 86400) / 3600 ))\n            minutes=$(( (uptime_seconds % 3600) / 60 ))\n            seconds=$((uptime_seconds % 60))\n            \n            echo \"系统运行时间: ${days}天 ${hours}小时 ${minutes}分钟 ${seconds}秒\"\n            \n            # 显示启动时间\n            boot_date=$(date -r $boot_time \"+%Y-%m-%d %H:%M:%S\" 2>/dev/null)\n            [[ -n \"$boot_date\" ]] && echo \"系统启动时间: $boot_date\"\n        else\n            echo \"系统运行时间: 无法获取\"\n        fi\n    else\n        echo \"系统运行时间: 无法获取 (sysctl命令不可用)\"\n    fi\nelse\n    # Linux获取运行时间\n    if [[ -f /proc/uptime ]]; then\n        uptime_seconds=$(awk '{print $1}' /proc/uptime 2>/dev/null)\n        if [[ -n \"$uptime_seconds\" ]]; then\n            days=$((uptime_seconds / 86400))\n            hours=$(( (uptime_seconds % 86400) / 3600 ))\n            minutes=$(( (uptime_seconds % 3600) / 60 ))\n            seconds=$((uptime_seconds % 60))\n            echo \"系统运行时间: ${days}天 ${hours}小时 ${minutes}分钟 ${seconds}秒\"\n            \n            # 显示启动时间\n            current_time=$(date +%s)\n            boot_time=$((current_time - ${uptime_seconds%.*}))\n            boot_date=$(date -d \"@$boot_time\" \"+%Y-%m-%d %H:%M:%S\" 2>/dev/null)\n            [[ -n \"$boot_date\" ]] && echo \"系统启动时间: $boot_date\"\n        else\n            echo \"系统运行时间: 无法获取\"\n        fi\n    else\n        echo \"系统运行时间: 无法获取 (/proc/uptime不存在)\"\n    fi\nfi\n\n# 显示uptime命令的输出作为补充\nif command -v uptime &>/dev/null; then\n    echo -n \"uptime命令输出: \"\n    uptime_output=$(uptime 2>/dev/null)\n    [[ -n \"$uptime_output\" ]] && echo \"$uptime_output\" || echo \"无法获取\"\nfi\n\n# 时区信息\necho \"=== 时区信息 ===\"\n\nif [[ -f /etc/timezone ]]; then\n    echo \"时区: $(cat /etc/timezone)\"\nelif command -v timedatectl &>/dev/null; then\n    timezone=$(timedatectl show --property=Timezone --value 2>/dev/null)\n    [[ -n \"$timezone\" ]] && echo \"时区: $timezone\"\nelif [[ -f /etc/localtime ]]; then\n    # 尝试从/etc/localtime推断时区\n    if [[ \"$OS_TYPE\" == \"Linux\" ]]; then\n        timezone_link=$(readlink /etc/localtime 2>/dev/null)\n        if [[ -n \"$timezone_link\" ]]; then\n            timezone=$(echo \"$timezone_link\" | sed 's|.*/zoneinfo/||')\n            echo \"时区: $timezone\"\n        fi\n    fi\nfi\n\n# 显示当前时间\necho \"当前时间: $(date '+%Y-%m-%d %H:%M:%S')\"\n\n# CPU信息\necho \"=== CPU信息 ===\"\n\nif [[ \"$OS_TYPE\" == \"macOS\" ]]; then\n    cpu_info=$(sysctl -n machdep.cpu.brand_string 2>/dev/null || echo \"未知\")\n    echo \"CPU型号: $cpu_info\"\n    echo \"CPU核心数: $(sysctl -n hw.ncpu 2>/dev/null || echo \"未知\")\"\nelif [[ -f /proc/cpuinfo ]]; then\n    cpu_model=$(grep -m1 \"model name\" /proc/cpuinfo 2>/dev/null | cut -d: -f2 | sed 's/^[ \\t]*//')\n    cpu_cores=$(grep -c \"^processor\" /proc/cpuinfo 2>/dev/null || echo \"未知\")\n    echo \"CPU型号: ${cpu_model:-未知}\"\n    echo \"CPU核心数: $cpu_cores\"\n    \n    # 显示CPU频率（如果可用）\n    cpu_mhz=$(grep -m1 \"cpu MHz\" /proc/cpuinfo 2>/dev/null | cut -d: -f2 | sed 's/^[ \\t]*//')\n    [[ -n \"$cpu_mhz\" ]] && echo \"CPU频率: ${cpu_mhz} MHz\"\nelse\n    echo \"CPU型号: 无法获取\"\nfi\n\n# 内存信息\necho \"=== 内存信息 ===\"\n\nif [[ \"$OS_TYPE\" == \"macOS\" ]]; then\n    memory_bytes=$(sysctl -n hw.memsize 2>/dev/null)\n    if [[ -n \"$memory_bytes\" ]]; then\n        memory_gb=$(echo \"$memory_bytes\" | awk '{printf \"%.2f\", $1/1024/1024/1024}')\n        echo \"内存大小: ${memory_gb}GB\"\n    fi\nelif [[ -f /proc/meminfo ]]; then\n    total_memory=$(grep -m1 \"MemTotal\" /proc/meminfo 2>/dev/null | awk '{print $2}')\n    if [[ -n \"$total_memory\" ]]; then\n        memory_gb=$(echo \"$total_memory\" | awk '{printf \"%.2f\", $1/1024/1024}')\n        echo \"内存大小: ${memory_gb}GB\"\n        \n        free_memory=$(grep \"MemAvailable\" /proc/meminfo 2>/dev/null | awk '{print $2}')\n        if [[ -n \"$free_memory\" ]]; then\n            free_gb=$(echo \"$free_memory\" | awk '{printf \"%.2f\", $1/1024/1024}')\n            used_gb=$(echo \"$total_memory $free_memory\" | awk '{printf \"%.2f\", ($1-$2)/1024/1024}')\n            use_percent=$(echo \"$total_memory $free_memory\" | awk '{printf \"%.1f\", 100-($2*100/$1)}')\n            echo \"内存使用: 已用 ${used_gb}GB / 可用 ${free_gb}GB (使用率: ${use_percent}%)\"\n        fi\n    fi\nelse\n    echo \"内存大小: 无法获取\"\nfi\n\n# 磁盘信息\necho \"=== 磁盘分区信息 ===\"\n\necho \"磁盘使用情况:\"\nif command -v df &>/dev/null; then\n    df -h 2>/dev/null | grep -E \"^/dev/\" | while read line; do\n        echo \"  $line\" | awk '{\n            printf \"  %s: 总大小=%s, 已用=%s, 可用=%s, 使用率=%s, 挂载点=\", \n                   $1, $2, $3, $4, $5;\n            for(i=6;i<=NF;i++) printf \"%s \", $i;\n            print \"\"\n        }'\n    done\nelse\n    echo \"  df命令不可用\"\nfi\n\necho -e \"\\n=== 物理磁盘信息 ===\"\n\nif [[ \"$OS_TYPE\" == \"macOS\" ]]; then\n    if command -v diskutil &>/dev/null; then\n        diskutil list 2>/dev/null | grep -A5 \"/dev/disk\" | while read line; do\n            if [[ \"$line\" =~ /dev/disk ]]; then\n                echo \"  $line\"\n            fi\n        done\n    else\n        echo \"  diskutil命令不可用\"\n    fi\nelif command -v lsblk &>/dev/null; then\n    lsblk -d -o NAME,SIZE,TYPE,MODEL 2>/dev/null | grep disk | head -5\nelif [[ -f /proc/partitions ]]; then\n    cat /proc/partitions 2>/dev/null | grep -v \"major\" | grep -E \"^[[:space:]]*[0-9]\" | awk '{print $4, $3}' | while read name size; do\n        if [[ \"$name\" =~ ^[hs]d[a-z]$ ]] || [[ \"$name\" =~ ^nvme ]]; then\n            size_gb=$(echo \"$size\" | awk '{printf \"%.2f\", $1/1024/1024}')\n            echo \"  $name: ${size_gb}GB\"\n        fi\n    done\nfi\n\n# 用户信息\necho -e \"\\n=== 当前登录用户 ===\"\necho \"  当前用户: $USER\"\nif command -v who &>/dev/null; then\n    users=$(who 2>/dev/null | awk '{print $1}' | sort | uniq)\n    user_count=$(echo \"$users\" | wc -w 2>/dev/null)\n    [[ \"$user_count\" -gt 1 ]] && echo \"  其他登录用户: $(echo \"$users\" | tr '\\n' ' ')\"\n    \n    # 显示登录终端和登录时间\n    echo -e \"\\n  登录会话详情:\"\n    who 2>/dev/null | head -5 | while read line; do\n        echo \"    $line\"\n    done\nfi\n\n# 系统负载信息\necho -e \"\\n=== 系统负载信息 ===\"\nif [[ -f /proc/loadavg ]]; then\n    load=$(cat /proc/loadavg 2>/dev/null)\n    [[ -n \"$load\" ]] && echo \"  系统负载: $load\" || echo \"  系统负载: 无法获取\"\nelif command -v sysctl &>/dev/null && [[ \"$OS_TYPE\" == \"macOS\" ]]; then\n    load=$(sysctl -n vm.loadavg 2>/dev/null)\n    [[ -n \"$load\" ]] && echo \"  系统负载: $load\" || echo \"  系统负载: 无法获取\"\nfi\n\necho -e \"\\e[0m\"\n```","tags":["树莓派","Linux","Windows","实用脚本"],"categories":["实用脚本"]},{"title":"树莓派部署旁路由实现全局科学上网","url":"/2025/12/11/树莓派部署旁路由实现全局科学上网/","content":"\n### 简单介绍\n旁路由架构是：主路由依旧负责拨号和DHCP，而树莓派作为旁路由接入同一网段，通过静态IP和自定义路由规则，让家里的设备可以选择是否把流量交由树莓派处理。这种模式不会破坏原有网络结构，也能随时拔掉。\n\n### 目的\n在Docker中运行OpenWrt旁路网关（透明网关）\n- 结构图如下\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_11.png)\n\n### 开启网卡的混杂模式\n- 是为了让我们的虚拟机和宿主机能同时接收数据包\n- 以下二选一选择执行\n  - 插线形式，请执行：\n  ```shell\n  sudo ip link set dev eth0 promisc on\n  ```\n  - WIFI形式，请执行：\n  ```shell\n  sudo ip link set dev wlan0 promisc on\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_0.png)\n\n### 下载OpenWrt镜像\n- 在终端界面执行以下命令，下载镜像文件\n  ```shell\n  docker pull buddyfly/openwrt-aarch64\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_1.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_2.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_3.png)\n- 下载完后，可选择查看镜像是否在docker镜像里，执行以下命令\n  ```shell\n  docker images\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_4.png)\n\n### 检查是否存在Docker虚拟网络(macnet)\n- 第一次执行之前，一般情况是没有的，不过我们还是要执行看看先\n- 查看所有网络列表\n  ```shell\n  docker network ls\n  ```\n- 如果出现重名，可执行下面命令用来删除已存在的同名网络\n  ```shell\n  docker network rm `填写NAME`\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_5.png)  \n\n### 创建Docker虚拟网络\n- 虚拟网络名称为`macnet`，驱动为`macvlan`模式，将`subnet 10.10.10.0`修改为你自己主路由的网段，`gateway 10.10.10.1`修改为你自己的主路由网关。\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_6.png)\n- 图中的示范命令如下\n  ```shell\n  docker network create -d macvlan --subnet=10.10.10.0/24 --gateway=10.10.10.1 -o parent=eth0 macnet\n  ```\n- 以下二选一选择执行(以我自己的为例)\n  - 插线形式，请执行：\n  ```shell\n  docker network create -d macvlan --subnet=192.168.0.0/24 --gateway=192.168.0.1 -o parent=eth0 macnet\n  ```\n  - WIFI形式，请执行：\n  ```shell\n  docker network create -d macvlan --subnet=192.168.0.0/24 --gateway=192.168.0.1 -o parent=wlan0 macnet\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_7.png)\n\n> 如果不清楚自己的主路由器网关地址和网段，那就请看下面这一章节。\n\n### 如何查看主路由器的网关地址和网段（Windows）\n- 通过路由器管理界面（通用方法）\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_8.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_9.png)\n- 通过命令行形式查看\n  - 按win键 + R键\n  - 输入 `cmd`\n  - 在命令行输入 `ipconfig`\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_12.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_10.png)\n\n### 验证【Docker虚拟网络】是否创建成功\n- 输入命令 `docker network ls`\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_13.png)\n\n### 启动OpenWrt容器\n- 执行下面命令\n  ```shell\n  docker run --restart always -d --network macnet --privileged buddyfly/openwrt-aarch64:latest\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_14.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_15.png)\n\n### 查看运行中的OpenWrt容器\n- 执行下面命令\n  ```shell\n  docker ps -a | grep openwrt\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_16.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_17.png)\n\n### 修改OpenWrt容器的IP地址\n- 进入容器内部\n  ```shell\n  docker exec -it a94607d8119f ash\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_20.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_18.png)\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_19.png)\n- 编辑网卡文本\n  ```shell\n  sudo nano /etc/config/network\n  ```\n- 修改文件如下，将 `option ipaddr '192.168.0.252'` 改为你想作为旁路由网关的空闲地址（我的网段为 `192.168.0.X`），主路由IPV4地址改为你自己的即可。\n  ```shell\n  option ipaddr '192.168.0.252'  # 252这是我自定义的\n  option gateway '192.168.0.1'   # 这是我的主路由IPV4地址\n  option dns '192.168.0.1'       # 保持和gateway一致\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_21.png)\n- 重启容器网卡\n  ```shell\n  /etc/init.d/network restart\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_22.png)\n\n### 校验【修改OpenWrt容器的IP地址】修改是否成功\n- 现在我们可以call下外部的主路由IP，试试连通性。\n  ```shell\n  ping 192.168.0.1   # 换成你自己的\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_23.png)\n> 显示和我的截图一样，收到数据包就可以了。\n\n### 永久开启网卡混杂模式\n- 先退出docker容器，然后再去宿主机里进行下面操作\n- 先执行 `sudo nano /etc/network/interfaces`\n- 添加内容\n  ```shell\n  up ip link set eth0 promisc on    # 插线形式用这个\n  up ip link set wlan0 promisc on   # WIFI形式用这个\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_24.png)\n- 添加内容后，按 ESC 并输入 :wq 正常保存\n- 用cat命令查看是否已写入 `cat /etc/network/interfaces`\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_25.png)\n- 如果文件权限有问题，那执行下面操作\n  ```shell\n  ls -l /etc/network/interfaces\n  sudo chmod 644 /etc/network/interfaces\n  ```\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_26.png)\n\n### 登录树莓派旁路由网关系统（旁路网关配置）\n- 网址输入\n  ```shell\n  http://192.168.0.252    # 改为你自己设置的\n  ```\n- 初始用户名 root 密码 password\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_27.png)\n- 先做最重要的事情：改密码。\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_28.png)\n\n### 更改系统主题\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_29.png)\n\n### 更改上级路由\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_30.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_31.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_32.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_33.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_34.png)\n\n### 网络加速设置\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_35.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_36.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_37.png)\n\n### 科学上网\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_38.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_39.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_40.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_41.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_42.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_43.png)\n\n### 配置旁路网关\n- 把局域网内需要连接的设备的WiFi改为手动配置\n- 然后IP地址改为192.168.0.XXX改为你愿意的地址\n- 子网掩码改为255.255.255.0\n- 路由器（网关）改为192.168.0.254，这个其实是OpenWrt的IPv4地址\n- DNS服务器改为192.168.0.254，同OpenWrt的IPv4地址\n  ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE%E9%83%A8%E7%BD%B2%E6%97%81%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E5%85%A8%E5%B1%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/RaspberryPi_BypassRoute_44.png)\n\n### 验证网关是否生效(树莓派验证)\n- `ip route show`\n- `ping 8.8.8.8`\n- `curl -Iv https://www.youtube.com --connect-timeout 10`\n- `curl -Iv https://www.google.com --connect-timeout 10`","tags":["树莓派"],"categories":["树莓派"]},{"title":"树莓派4B搭建面板1Panel","url":"/2025/12/10/树莓派4B搭建面板1Panel/","content":"\n### 简单介绍\n在树莓派上折腾一个面板，像是在一台小小的飞船里加装一套“宇宙驾驶舱”。1Panel 本来面向 x86，但它已经提供了 arm64 的版本，正好吻合树莓派 4B 的架构，所以你完全可以在你的 Pi 上跑起来，让它像台袖珍服务器一样管理得井井有条。\n\n### 准备工作\n1. 硬件要求\n    - 树莓派4B（2GB或以上内存推荐）\n    - MicroSD卡（至少16GB，建议Class 10或更高）\n    - 电源适配器、网线或WiFi连接\n2. 安装Raspberry Pi OS\n    - 请参考 https://tech-roy.uk/2025/06/07/树莓派4B安装Rpi-OS-Legacy-Lite/\n3. 更新系统：通过SSH连接树莓派，运行\n```shell\nsudo apt update && sudo apt upgrade -y\n```\n4. 安装Docker（1Panel必须依赖Docker）\n```shell\nsudo apt install curl -y\ncurl -fsSL https://get.docker.com | sudo sh\nsudo usermod -aG docker $USER  # 添加当前用户到docker组，重启生效\n```\n重启树莓派：`sudo reboot`\n\n### 安装脚本\n树莓派上装好Ubuntu/Debian，然后直接跑1Panel官方脚本。脚本会自动检测你当前系统的架构并下载对应版本。如果你现在系统是64位（树莓派OS默认有64位版）\n1. 运行一键安装脚本\n```text\ncurl -sSL https://resource.fit2cloud.com/1panel/package/quick_start.sh -o quick_start.sh && sudo bash quick_start.sh\n```\n- 脚本会自动检测ARM架构（树莓派兼容），安装过程约5-10分钟。\n- 提示设置安装目录（默认为/opt）、端口（默认36230）、用户名/密码（推荐自定义强密码）。\n- 如果提示Docker未安装，它会自动引导修复。\n\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_0.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_1.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_2.png)\n\n2. 安装完成提示\n   - 会出现访问地址，如`http://<树莓派IP>:36230`\n\n### 访问1Panel\n1. 获取树莓派IP\n   - 树莓派终端运行`hostname -I | awk '{print $1}'`\n      ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_6.png)\n2. 浏览器访问\n   - 在电脑的浏览器输入`http://<树莓派IP>:端口号/随机入口`（例如http://192.168.0.109:36230/roy）\n   - 随机入口指的是面板安全入口，在安装过程中有设置此配置。\n     ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_7.png)\n     ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_8.png)\n3. 首次登录\n   - 使用安装时设置的用户名/密码。\n   ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_4.png)\n   ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_5.png)\n4. 获取信息\n   - 如果找不到自己的用户名、密码、入口，可以在终端运行下面的命令进行查看。\n   ```shell\n   sudo 1pctl user-info\n   ```\n   ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_9.png)\n\n### 版本信息\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E6%90%AD%E5%BB%BA%E9%9D%A2%E6%9D%BF1Panel/Install_1Panel_3.png)\n\n### 常见问题与优化\n- ARM兼容：树莓派4B完美支持，但部分应用需ARM版镜像（1Panel会自动选择）。\n- 与CasaOS共存：安装在不同端口，不会干扰。CasaOS默认80端口，1Panel用自定义端口。\n- 卸载：运行`sudo 1pctl uninstall`\n- 更新：面板内自动检查，或终端`sudo 1pctl update`\n- 性能：树莓派4B运行流畅，但安装多应用时监控温度（加散热片）。\n- 防火墙：如果启用ufw，开放端口：`sudo ufw allow 端口号`\n- 端口冲突：如果默认端口被占，安装时指定其他端口，或修改/opt/1panel/config/config.yaml后，重启服务：`sudo systemctl restart 1panel`\n- 修改密码：修改密码可执行命令 `sudo 1pctl update password`\n\n### 参考材料\n- 1Panel仓库地址：https://github.com/1Panel-dev/1Panel\n- 官方网站: https://1panel.cn\n- 项目文档: https://1panel.cn/docs","tags":["树莓派"],"categories":["树莓派"]},{"title":"树莓派4B安装CasaOS","url":"/2025/12/09/树莓派4B安装CasaOS/","content":"\n### 简单介绍\nCasaOS是一个开源的家庭云系统，基于Docker生态设计，专为家庭场景打造。它提供简洁的Web界面，支持一键安装NAS、媒体服务器、智能家居等应用，非常适合树莓派4B作为家庭服务器使用。CasaOS完全兼容Raspberry Pi OS（推荐使用64位版本），安装过程简单，只需几分钟。\n\n### 准备工作\n1. 硬件要求\n   - 树莓派4B（2GB或以上内存推荐）\n   - MicroSD卡（至少16GB，建议Class 10或更高）\n   - 电源适配器、网线或WiFi连接\n2. 安装Raspberry Pi OS\n   - 请参考 https://tech-roy.uk/2025/06/07/树莓派4B安装Rpi-OS-Legacy-Lite/\n\n### 安装系统依赖（更新系统）\n- 使用SSH连接树莓派\n  - （默认用户：pi，密码：raspberry）\n- 运行以下命令更新软件包\n   ```shell\n   sudo apt update && sudo apt upgrade -y\n   ```\n- 安装curl（如果未安装）\n   ```shell\n   sudo apt install curl -y\n   ```\n\n### 运行CasaOS脚本\nCasaOS支持一键安装脚本。打开终端，运行以下命令：\n```text\ncurl -fsSL https://get.casaos.io | sudo bash\n```\n- 脚本会自动下载并安装CasaOS，包括Docker依赖。\n- 安装过程会提示设置CasaOS管理员用户名和密码（默认用户名：casaos，密码：casaos，可自定义）。\n- 安装完成后，CasaOS会自动启动。\n\n备选命令（如果curl不可用）\n```text\nwget -qO- https://get.casaos.io | sudo bash\n```\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85CasaOS/Install_CasaOS_0.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85CasaOS/Install_CasaOS_1.png)\n\n### 访问CasaOS Web界面\n1. 查找IP地址\n   - 在树莓派终端运行：`hostname -I`（获取本地IP，如192.168.x.x）\n2. 浏览器访问\n   - 在同一网络的电脑/手机浏览器输入：`http://<树莓派IP>:80`（例如：http://192.168.0.109）\n   - 登录CasaOS（使用刚才设置的用户名/密码）\n   - 首次登录会引导设置，之后即可浏览应用商店，一键安装如Nextcloud、Plex、Home Assistant等应用。\n\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85CasaOS/Install_CasaOS_2.png)\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85CasaOS/Install_CasaOS_3.png)\n\n### 卸载CasaOS（可选）\n打开终端，运行以下命令：\n```text\ncurl -fsSL https://get.casaos.io/uninstall | sudo bash\n```\n\n### 常见问题与提示\n- 端口冲突：默认使用80端口，如果已占用（如Apache），可编辑CasaOS配置文件修改端口。\n- 性能优化：树莓派4B运行CasaOS流畅，但安装应用时监控CPU/内存使用。建议使用SSD外接存储以提升速度。\n- 更新CasaOS：在Web界面“设置”中检查更新，或终端运行`casaos-ctl update`。\n- 防火墙：如果启用ufw，确保开放80端口：`sudo ufw allow 80`。","tags":["树莓派"],"categories":["树莓派"]},{"title":"创建.bashrc文件","url":"/2025/06/08/创建-bashrc文件/","content":"\n## 创建.bashrc\n\n```shell\ntouch /home/roy/.bashrc\n```\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E5%88%9B%E5%BB%BA.bashrc%E6%96%87%E4%BB%B6/Create_bashrc_0.png)\n`P.S.: “roy”为用户名，请替换为您的用户名。`\n\n## 进入编辑模式\n\n```shell\ncd /home/roy/\nsudo nano /home/roy/.bashrc\n```\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E5%88%9B%E5%BB%BA.bashrc%E6%96%87%E4%BB%B6/Create_bashrc_1.png)\n\n## ~./.bashrc\n\n```shell\n# 添加用户本地 bin 目录到 PATH\n# Global Environment Variable\nexport PATH=\"$HOME/.local/bin:$PATH\"\n\n# Hexo\nalias hexocgd=\"hexo clean && hexo generate && hexo deploy\"\nalias hexo4000=\"hexo clean && hexo generate && hexo server\"\n\n# Quickly Command\nalias rmd=\"rm -rf\"\n#alias e=\"vim ~/.bashrc\"\nalias e=\"nano ~/.bashrc\"\nalias s=\"source ~/.bashrc\"\nalias c=\"clear\" \nalias la=\"ls -la\" \nalias ll=\"ls -lah --color=auto\"\nalias grep=\"grep --color=auto\"\nalias catbashrc=\"cat ~/.bashrc\"\nalias ipcheck=\"ip route get 8.8.8.8\"\nalias testgoogle=\"curl -Iv https://www.google.com --connect-timeout 10\"\nalias testyoutube=\"curl -Iv https://www.youtube.com --connect-timeout 10\"\nalias restartdhcpcd=\"sudo systemctl restart dhcpcd\"\nalias dockerrestart=\"sudo systemctl daemon-reload && sudo systemctl restart docker && sudo systemctl status docker\"\nalias wificheck=\"sudo nmcli dev wifi list\"\nalias editdhcpcdconfig=\"sudo nano /etc/dhcpcd.conf\"\nalias rpishutdown=\"sudo shutdown -h now\"\nalias rpireboot=\"sudo reboot\"\n\n# Docker command\nalias dps='docker ps -a --format \"table {{.Names}}\\t{{.ID}}\\t{{.Status}}\\t{{.Image}}\"'\n\n# Quickly come to file address\nalias ..=\"cd ..\"\nalias ...=\"cd ../..\"\nalias ~=\"cd /home/roy\"\n\n# Functions \n# Create a directory and immediately enter it\nmkcd() {\n    mkdir -p \"$1\" && cd \"$1\"\n}\n```\n\n## 使其生效\n```shell\nsource /home/roy/.bashrc\n```\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E5%88%9B%E5%BB%BA.bashrc%E6%96%87%E4%BB%B6/Create_bashrc_2.png)\n\n## 查看文件是否创建\n```shell\nls -la /home/roy/.bashrc\n```\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E5%88%9B%E5%BB%BA.bashrc%E6%96%87%E4%BB%B6/Create_bashrc_3.png)\n\n## 拥有文件所有权限\n```shell\nsudo chmod -R 777 /home/roy/.bashrc\n```\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E5%88%9B%E5%BB%BA.bashrc%E6%96%87%E4%BB%B6/Create_bashrc_4.png)\n","tags":["树莓派","Linux"],"categories":["树莓派"]},{"title":"树莓派4B安装Rpi OS Legacy Lite","url":"/2025/06/07/树莓派4B安装Rpi-OS-Legacy-Lite/","content":"\n## 前言\n各位看官，此篇是DIY个人NAS的第一篇，首先我们来给树莓派单板机安装RPI OS，然后在此基础上，我们可以安装各种第三方应用来实现NAS的基础服务。  \n\n### 所需设备  \n- [x] 树莓派4B型号  \n- [x] TF内存卡64G  \n- [x] TF读卡器  \n- [x] 树莓派电源线  \n- [x] 网线  \n- [x] HDMI线  \n- [x] Mini HDMI线转换头  \n- [x] 显示器  \n\n### 步骤\n1. 首先我们需要对TF内存卡格式化加安装树莓派OS系统。\n2. 把TF内存卡插入到TF读卡器内。  \n    ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/TF_reader.png)\n3. 先下载Raspberry Pi Imager（树莓派镜像烧录工具）  \n4. 从树莓派官网下载烧录工具imager_1.8.5(下载最新的版本)，不然其他平台很难保证其安全性。  \n    4.1 点击 –> ![树莓派官网下载链接](https://www.raspberrypi.com/software/)  \n    4.2 进入主页，点击最上面导航栏的’Software’  \n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_offical_0.jpg)\n    4.3 往下拉，找到’Download for XXX’  \n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_offical_1.jpg)\n    4.4 下载到本地盘任意位置即可  \n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/imager_1.8.5.jpg)\n    4.5 下载完后，双击进行安装，一直点击’下一步’即可，或者安装到任意你喜欢的盘符位置  \n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/imager_0.jpg)\n5. 点击树莓派启动盘制作工具进行烧录树莓派OS系统。  \n    ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_v1.9.0.jpg)\n    5.1 点击【树莓派设备·选择设备】参考下面截图，来配置个人需求。  \n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_select_device.jpg)\n    5.2 点击【操作系统·选择操作系统】  \n        ***这里补充一下:***  \n        如果要节省功耗，请选择Raspberry Pi OS(Legacy,64-bit)Lite版本，因为此系统无桌面，只有命令行。\n        如果不担心功耗，请选择Raspberry Pi OS(Legacy,64-bit)Full版本，此版本是有桌面界面。\n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_select_OS_0.jpg)\n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_select_OS_1.jpg)\n    5.3 点击【储存设备·选择存储设备】  \n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_select_TF_card.jpg)\n    5.4 然后点击’下一步’，会出现弹框，点击’编辑设置’  \n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_config_0.jpg)\n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_config_1.jpg)\n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_config_2.jpg)\n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_config_3.jpg)\n    5.5 最后点击’保存’与’下一步’，会出现警告弹框，再点击’确认’即可，会删除卡内现存数据，如需要，提前做好备份。  \n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_warning_msg.jpg)\n        ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/rpi_tool_writing_in.jpg)\n6. 烧录完毕，关闭烧录框。  \n7. 桌面会出现提示XX格式化的弹框，无需担心，点击’取消’即可。  \n8. 把TF卡拔出后插入到树莓派里。  \n    ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/RPI4B.png)\n9. 插上MiniHDMI转换器，用HDMI线链接树莓派与显示器。  \n    ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/Mini_HDMI.png)\n10. 开机，等待几分钟，让树莓派进行系统初始化。  \n11. 进入命令行界面后，输入登录用户名和登录密码。  \n    ![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E6%A0%91%E8%8E%93%E6%B4%BE4B%E5%AE%89%E8%A3%85RpiOSLegacyLite/Login_page.jpg)\n12. 恭喜，此时已经成功安装了树莓派OS系统。  \n\n\n## 结束语  \n完成上面每一步后，接下来我们可以DIY这个乌班图系统，请各位看官们持续关注这个技术博客，感谢~！\n\n“技術分享 技術無界 開源至上”\n","tags":["树莓派"],"categories":["树莓派"]},{"title":"记录折腾树莓派的全过程","url":"/2025/06/07/记录折腾树莓派的全过程/","content":"\n## 记录篇章链接\n1. 链接1\n2. 链接2\n3. 链接3\n4. 链接4\n5. 链接5\n\n## 制作感受\n从XX\n\n## 参考链接\n1. 参考1\n2. 参考2\n3. 参考3\n4. 参考4\n5. 参考5\n\n","tags":["树莓派"],"categories":["树莓派"]},{"title":"开通博客·技术分享·开源至上","url":"/2025/06/07/开通博客·技术分享·开源至上/","content":"\n## 开通时间\n2025年06月07日\n\n## 目的\n通过我的实践经历，来记录实践过程，提高写作能力，分享技术细节。\n\n## Slogan\n技术分享 技术无界 开源至上\n\n## 网站链接\nhttps://tech-roy.uk/\n\n## 网站头像\n![](https://pub-ed71167c1a14475cbc305b5afb0e5173.r2.dev/PicGo/%E5%85%B6%E4%BB%96/Sherlock_logo.png)\n","tags":["生活"],"categories":["生活"]}]